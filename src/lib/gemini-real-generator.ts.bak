// GENERADOR REAL con Gemini 2.5 Flash Image Preview (Nano Banana)
import { GoogleGenerativeAI } from '@google/generative-ai';
import { config } from './config';
import { geminiLogger } from './logger';
import { sanitizePrompt, validateImageInput } from './security';

// MODELO CORRECTO DE GENERACI√ìN DE IM√ÅGENES
const IMAGE_MODEL = 'gemini-2.5-flash-image-preview';

// Inicializar Gemini API de forma segura
function initializeGemini(): GoogleGenerativeAI {
  const apiKey = config.gemini.getApiKey();
  geminiLogger.sensitive('Inicializando con API Key', apiKey);
  return new GoogleGenerativeAI(apiKey);
}

// FUNCI√ìN PRINCIPAL - USA EL MODELO REAL DE GEMINI
export async function generateWithGeminiReal(
  canvasBase64: string,
  userPrompt?: string,
  styles?: string[]
): Promise<{ generatedImages: string[], error?: string }> {
  geminiLogger.log('=== NANO BANANA - GENERACI√ìN REAL CON GEMINI ===');
  geminiLogger.log('Usando modelo:', IMAGE_MODEL);
  geminiLogger.log('Entrada recibida:', {
    canvasLength: canvasBase64?.length || 0,
    hasPrompt: !!userPrompt,
    styles: styles
  });
  
  try {
    const ai = initializeGemini();
    const model = ai.getGenerativeModel({ 
      model: IMAGE_MODEL // MODELO DE GENERACI√ìN DE IM√ÅGENES
    });
    
    // Construir el prompt descriptivo
    let prompt = userPrompt || 'Transform this sketch into a detailed, photorealistic image';
    
    // Agregar estilos si los hay
    if (styles && styles.length > 0) {
      const styleMap: Record<string, string> = {
        'anime_moderno': 'in modern anime style with vibrant colors',
        'realista': 'in photorealistic style with natural lighting',
        'ultra_realista': 'in ultra-realistic style with fine details and textures',
        'manga_bn': 'in black and white manga style',
        'pixel_art': 'in pixel art style',
        'line_art': 'as clean line art'
      };
      
      const styleDescriptions = styles.map(s => styleMap[s] || s).join(', ');
      prompt += `, ${styleDescriptions}`;
    }
    
    // A√±adir instrucciones espec√≠ficas para mejorar la generaci√≥n
    prompt += `. Analyze the sketch carefully and:
    - If there are mountains, render them with realistic textures, snow caps, and atmospheric perspective
    - If there are trees, add detailed foliage and natural colors
    - If there's a sun, add proper lighting and lens flares
    - If there are clouds, make them volumetric and realistic
    - If there's a house, add architectural details, windows, doors, and textures
    - Maintain the composition and layout from the original sketch
    - Use professional photography lighting and color grading
    - Make it look like a high-quality photograph or professional artwork
    
    IMPORTANT FORMAT REQUIREMENTS:
    - Generate the image to fill the ENTIRE frame
    - DO NOT add black bars, letterboxing, or borders
    - Use the full canvas area for the image
    - Match the aspect ratio of the input sketch exactly
    - If the sketch is wide, make a wide image
    - If the sketch is tall, make a tall image
    - Fill ALL white space with generated content`;
    
    geminiLogger.log('Prompt completo:', prompt);
    
    // Clean base64 if it has data URL prefix
    const cleanCanvas = canvasBase64.includes(',') ? canvasBase64.split(',')[1] : canvasBase64;
    geminiLogger.log('Enviando imagen del canvas (longitud):', cleanCanvas.length);
    
    // Validate base64
    if (!cleanCanvas || cleanCanvas.length < 100) {
      console.error('‚ùå Canvas base64 inv√°lido o muy corto');
      return {
        generatedImages: [],
        error: 'El canvas est√° vac√≠o o es inv√°lido'
      };
    }
    
    // ENVIAR AL MODELO DE GENERACI√ìN DE IM√ÅGENES - FORMATO CORRECTO
    const result = await model.generateContent([
      prompt,  // Primero el texto
      {
        inlineData: {
          data: cleanCanvas,  // Base64 limpio
          mimeType: 'image/png'
        }
      }
    ]);
    
    console.log('üì• Respuesta recibida del modelo');
    
    const response = await result.response;
    
    // Buscar la imagen generada en la respuesta
    if (response.candidates && response.candidates[0]) {
      const candidate = response.candidates[0];
      console.log('‚úÖ Candidato encontrado');
      
      if (candidate.content && candidate.content.parts) {
        console.log(`üì¶ Partes en la respuesta: ${candidate.content.parts.length}`);
        
        // Buscar la imagen generada
        for (const part of candidate.content.parts) {
          // La imagen generada viene como inlineData
          if (part.inlineData && part.inlineData.data) {
            console.log('üéâ ¬°IMAGEN GENERADA ENCONTRADA!');
            console.log('üìä Tipo MIME:', part.inlineData.mimeType);
            console.log('üìè Tama√±o de datos:', part.inlineData.data.length);
            
            // DEVOLVER LA IMAGEN GENERADA
            return {
              generatedImages: [part.inlineData.data],
              error: undefined
            };
          }
          
          // Si hay texto, mostrarlo (puede ser explicaci√≥n del modelo)
          if (part.text) {
            console.log('üìù Texto del modelo:', part.text.substring(0, 200));
          }
        }
      }
    }
    
    // Si no se gener√≥ imagen
    console.error('‚ö†Ô∏è El modelo no devolvi√≥ una imagen generada');
    console.log('üí° Esto puede pasar si:');
    console.log('1. El modelo gemini-2.5-flash-image-preview no est√° disponible en tu regi√≥n');
    console.log('2. La API key no tiene permisos para generar im√°genes');
    console.log('3. El contenido fue bloqueado por filtros de seguridad');
    
    return {
      generatedImages: [],
      error: 'El modelo no gener√≥ una imagen. Verifica que gemini-2.5-flash-image-preview est√© disponible.'
    };
    
  } catch (error) {
    console.error('‚ùå Error llamando a Gemini:', error);
    
    if (error instanceof Error) {
      if (error.message.includes('404')) {
        return {
          generatedImages: [],
          error: 'Modelo gemini-2.5-flash-image-preview no encontrado. Puede no estar disponible en tu regi√≥n.'
        };
      }
      
      if (error.message.includes('API key')) {
        return {
          generatedImages: [],
          error: 'Error con la API key. Verifica que sea v√°lida.'
        };
      }
      
      return {
        generatedImages: [],
        error: error.message
      };
    }
    
    return {
      generatedImages: [],
      error: 'Error desconocido al generar imagen'
    };
  }
}

// Funci√≥n alternativa para edici√≥n local (imagen + m√°scara + instrucci√≥n)
export async function editWithGeminiReal(
  baseImage: string,
  maskImage: string,
  instruction: string
): Promise<{ generatedImages: string[], error?: string }> {
  console.log('üé® === EDICI√ìN LOCAL CON GEMINI ===');
  
  try {
    const ai = initializeGemini();
    const model = ai.getGenerativeModel({ 
      model: IMAGE_MODEL
    });
    
    // Prompt para edici√≥n local
    const prompt = `Edit this image following these instructions: ${instruction}
    The mask indicates the area to modify (white = edit, black = preserve).
    Maintain the style, lighting, and perspective of the original image.
    Only modify the masked area.`;
    
    console.log('üìù Instrucci√≥n de edici√≥n:', instruction);
    
    // Enviar imagen base + m√°scara + instrucci√≥n - FORMATO CORRECTO
    const result = await model.generateContent([
      prompt,
      {
        inlineData: {
          data: baseImage,
          mimeType: 'image/png'
        }
      },
      {
        inlineData: {
          data: maskImage,
          mimeType: 'image/png'
        }
      }
    ]);
    
    const response = await result.response;
    
    // Buscar imagen editada
    if (response.candidates && response.candidates[0]) {
      const candidate = response.candidates[0];
      
      if (candidate.content && candidate.content.parts) {
        for (const part of candidate.content.parts) {
          if (part.inlineData && part.inlineData.data) {
            console.log('‚úÖ Imagen editada generada');
            return {
              generatedImages: [part.inlineData.data],
              error: undefined
            };
          }
        }
      }
    }
    
    return {
      generatedImages: [],
      error: 'No se pudo editar la imagen'
    };
    
  } catch (error) {
    console.error('‚ùå Error en edici√≥n:', error);
    return {
      generatedImages: [],
      error: error instanceof Error ? error.message : 'Error desconocido'
    };
  }
}

// Funci√≥n para composici√≥n/transferencia de estilo (m√∫ltiples im√°genes)
export async function composeWithGeminiReal(
  images: string[],
  instruction: string
): Promise<{ generatedImages: string[], error?: string }> {
  console.log('üé≠ === COMPOSICI√ìN/TRANSFERENCIA DE ESTILO ===');
  
  try {
    const ai = initializeGemini();
    const model = ai.getGenerativeModel({ 
      model: IMAGE_MODEL
    });
    
    // Construir el contenido con todas las im√°genes - FORMATO CORRECTO
    const contents: any[] = [instruction]; // Texto primero
    
    images.forEach((img, index) => {
      console.log(`üì∏ A√±adiendo imagen ${index + 1}`);
      contents.push({
        inlineData: {
          data: img,
          mimeType: 'image/png'
        }
      });
    });
    
    const result = await model.generateContent(contents);
    const response = await result.response;
    
    // Buscar imagen compuesta
    if (response.candidates && response.candidates[0]) {
      const candidate = response.candidates[0];
      
      if (candidate.content && candidate.content.parts) {
        for (const part of candidate.content.parts) {
          if (part.inlineData && part.inlineData.data) {
            console.log('‚úÖ Imagen compuesta generada');
            return {
              generatedImages: [part.inlineData.data],
              error: undefined
            };
          }
        }
      }
    }
    
    return {
      generatedImages: [],
      error: 'No se pudo componer las im√°genes'
    };
    
  } catch (error) {
    console.error('‚ùå Error en composici√≥n:', error);
    return {
      generatedImages: [],
      error: error instanceof Error ? error.message : 'Error desconocido'
    };
  }
}

// Funci√≥n especial para edici√≥n con imagen base + overlay de ediciones
export async function editWithBaseAndOverlay(
  baseImage: string,        // Imagen generada anterior
  overlayCanvas: string,    // Canvas actual con las ediciones
  instruction?: string,
  styles?: string[]
): Promise<{ generatedImages: string[], error?: string }> {
  console.log('üé® === EDICI√ìN INTELIGENTE CON BASE + OVERLAY ===');
  console.log('üìä Detectando cambios y agregando elementos nuevos...');
  console.log('üì∏ Tama√±os de entrada:', {
    baseImageLength: baseImage?.length || 0,
    overlayCanvasLength: overlayCanvas?.length || 0,
    hasInstruction: !!instruction,
    styles: styles
  });
  
  try {
    const ai = initializeGemini();
    const model = ai.getGenerativeModel({ 
      model: IMAGE_MODEL
    });
    
    // Construir prompt inteligente para edici√≥n
    let prompt = instruction || 'EDIT the base image by ADDING new elements. PRESERVE all existing content.';
    
    // Agregar instrucciones espec√≠ficas
    prompt += `
    
    CRITICAL EDITING INSTRUCTIONS - THIS IS AN EDIT, NOT A NEW GENERATION:
    
    1. ABSOLUTE IMAGE PRESERVATION:
    - The first image is the BASE that MUST be kept COMPLETELY INTACT
    - This is an EDITING task - PRESERVE 100% of the original image
    - ONLY ADD new elements, NEVER remove or change existing ones
    - Think of this as adding layers on top of the base image
    
    2. UNDERSTANDING THE STROKES:
    - The second image shows rough hand-drawn strokes over the base
    - These strokes are NOT meant to be visible in the final image
    - They are INSTRUCTIONS for what realistic elements to add
    - NEVER add the actual drawn lines/strokes to the image
    
    3. STROKE INTERPRETATION GUIDE:
    - Lines on mountains ‚Üí Add MORE REALISTIC MOUNTAINS in that area
    - Circles in sky ‚Üí Add REALISTIC sun, moon, or clouds (NOT circles)
    - Lines on ground ‚Üí Add REALISTIC trees, grass, paths (NOT lines)
    - Wavy lines ‚Üí Add REALISTIC water, rivers, waves (NOT wavy lines)
    - Shapes on buildings ‚Üí Add REALISTIC windows, doors (NOT shapes)
    - ANY drawn stroke ‚Üí Convert to a REALISTIC element that fits the context
    
    4. CRITICAL RULE - NO VISIBLE DRAWINGS:
    - DO NOT add sketchy lines, drawings, or doodles to the image
    - DO NOT show the hand-drawn strokes in any form
    - Every addition must look PHOTOREALISTIC or match the base style
    - The strokes are just a GUIDE for WHERE and WHAT to add
    
    5. STYLE MATCHING:
    - New elements MUST be in the EXACT same style as the base
    - If base is photorealistic ‚Üí additions are photorealistic
    - If base is anime ‚Üí additions are anime style
    - Perfect color, lighting, and texture matching
    - Seamless integration with no style changes
    
    6. SPATIAL ACCURACY - CRITICAL:
    - Elements drawn at the BOTTOM must appear at the BOTTOM of the image
    - Elements drawn at the TOP must appear at the TOP of the image
    - Elements drawn on the LEFT must appear on the LEFT side
    - Elements drawn on the RIGHT must appear on the RIGHT side
    - Elements drawn in the CENTER must appear in the CENTER
    - MAINTAIN the EXACT spatial positioning where strokes are drawn
    - If I draw 2 people at bottom-left, add them at bottom-left, NOT elsewhere
    - The LOCATION of drawn elements is AS IMPORTANT as WHAT they represent
    
    7. FINAL OUTPUT REQUIREMENTS:
    - The base image MUST remain 100% unchanged - only ADD new elements
    - Original image + new REALISTIC elements seamlessly integrated
    - NO visible drawings, sketches, or hand-drawn marks
    - Result should look like the new elements were always part of the image
    - All new elements in their EXACT drawn positions
    - This is an EDIT operation - preserve the base, add the new
    
    8. FORMAT REQUIREMENTS:
    - Maintain the EXACT dimensions of the base image
    - NO black bars, letterboxing, or borders
    - Fill the ENTIRE frame with content
    - Keep the same aspect ratio as the input
    - All edits must fit within the original image bounds
    
    CRITICAL: Preserve EXACT spatial positioning! Elements MUST appear WHERE they were drawn!
    NEVER show the drawn strokes - ALWAYS convert them to realistic elements!
    
    MOST IMPORTANT: This is an IMAGE EDITING task, NOT image generation.
    Take the BASE IMAGE and ADD new elements to it. DO NOT create a new image from scratch.
    The base image MUST be preserved exactly as it is, with only new elements added on top.
    `;
    
    // Agregar estilos si los hay
    if (styles && styles.length > 0) {
      const styleMap: Record<string, string> = {
        'anime_moderno': 'maintaining anime style',
        'realista': 'maintaining photorealistic style',
        'ultra_realista': 'maintaining ultra-realistic style',
        'manga_bn': 'maintaining manga style',
        'pixel_art': 'maintaining pixel art style',
        'line_art': 'maintaining line art style'
      };
      
      const styleDescriptions = styles.map(s => styleMap[s] || s).join(', ');
      prompt += `, ${styleDescriptions}`;
    }
    
    console.log('üìù Prompt de edici√≥n:', prompt.substring(0, 200));
    console.log('üñºÔ∏è Enviando imagen base + overlay...');
    
    // Validate base64 strings
    if (!baseImage || baseImage.length < 100) {
      console.error('‚ùå Base image invalida o muy corta');
      return {
        generatedImages: [],
        error: 'La imagen base es inv√°lida o est√° vac√≠a'
      };
    }
    
    if (!overlayCanvas || overlayCanvas.length < 100) {
      console.error('‚ùå Overlay canvas invalido o muy corto');
      return {
        generatedImages: [],
        error: 'El canvas con ediciones es inv√°lido o est√° vac√≠o'
      };
    }
    
    // Clean base64 if it has data URL prefix
    const cleanBase = baseImage.includes(',') ? baseImage.split(',')[1] : baseImage;
    const cleanOverlay = overlayCanvas.includes(',') ? overlayCanvas.split(',')[1] : overlayCanvas;
    
    console.log('üßπ Base64 limpio:', {
      baseLength: cleanBase.length,
      overlayLength: cleanOverlay.length
    });
    
    // Enviar ambas im√°genes al modelo con contexto claro
    const result = await model.generateContent([
      `${prompt}
      
      CONTEXT FOR THE TWO IMAGES:
      IMAGE 1 (BASE): The original image that MUST be preserved completely
      IMAGE 2 (OVERLAY): Shows the same image with hand-drawn strokes indicating where to add new elements
      
      TASK: Take IMAGE 1 and ADD the elements indicated by the strokes in IMAGE 2.
      The output should be IMAGE 1 with new realistic elements added where the strokes appear.
      DO NOT create a new image - EDIT the existing one by adding elements.`,
      {
        inlineData: {
          data: cleanBase,      // Primera: imagen base limpia
          mimeType: 'image/png'
        }
      },
      {
        inlineData: {
          data: cleanOverlay,   // Segunda: canvas con ediciones limpio
          mimeType: 'image/png'
        }
      }
    ]);
    
    console.log('üì• Respuesta recibida');
    
    const response = await result.response;
    
    // Buscar imagen generada
    if (response.candidates && response.candidates[0]) {
      const candidate = response.candidates[0];
      
      if (candidate.content && candidate.content.parts) {
        for (const part of candidate.content.parts) {
          if (part.inlineData && part.inlineData.data) {
            console.log('‚úÖ Imagen editada generada exitosamente');
            console.log('üéâ Nuevos elementos integrados a la imagen base');
            
            return {
              generatedImages: [part.inlineData.data],
              error: undefined
            };
          }
          
          if (part.text) {
            console.log('üìù Respuesta del modelo:', part.text.substring(0, 200));
          }
        }
      }
    }
    
    console.error('‚ö†Ô∏è No se pudo editar la imagen');
    return {
      generatedImages: [],
      error: 'No se pudo procesar la edici√≥n'
    };
    
  } catch (error: any) {
    console.error('‚ùå Error en edici√≥n con overlay:', error);
    console.error('üìù Detalles del error:', {
      message: error?.message,
      name: error?.name,
      stack: error?.stack?.substring(0, 500)
    });
    
    // Provide more specific error messages
    if (error?.message?.includes('Unable to process')) {
      return {
        generatedImages: [],
        error: 'Gemini no pudo procesar las im√°genes. Intenta con im√°genes m√°s simples o peque√±as.'
      };
    }
    
    if (error?.message?.includes('400')) {
      return {
        generatedImages: [],
        error: 'Formato de imagen inv√°lido. Aseg√∫rate de que las im√°genes sean JPG o PNG.'
      };
    }
    
    return {
      generatedImages: [],
      error: `Error al editar: ${error?.message || 'Error desconocido'}`
    };
  }
}

// Merge two images seamlessly
export async function mergeImages(
  image1: string,
  image2: string,
  prompt: string = 'Merge these two elements seamlessly into one cohesive image without any borders'
): Promise<string | null> {
  console.log('üîÄ === MERGING TWO IMAGES ===');
  console.log('üìä Input sizes:', {
    image1Length: image1?.length || 0,
    image2Length: image2?.length || 0,
    hasPrompt: !!prompt
  });
  
  try {
    const ai = initializeGemini();
    const model = ai.getGenerativeModel({ 
      model: IMAGE_MODEL
    });
    
    // Build content with both images
    const mergePrompt = `${prompt}
    
    MERGE INSTRUCTIONS:
    1. Combine these two elements into ONE cohesive image
    2. Create a natural blend between the elements
    3. Make them look like they belong together
    4. Use creative composition (overlap, side-by-side, or integrated)
    5. Maintain the best qualities of both images
    6. Create a harmonious final result
    
    FORMAT REQUIREMENTS:
    - NO black borders, bars, or letterboxing
    - Fill the entire canvas without padding
    - Maintain natural aspect ratio
    - Extend content edge-to-edge
    - Fill any empty space with appropriate content
    
    QUALITY:
    - High resolution output
    - Seamless blending
    - Professional composition
    - Natural lighting and shadows where elements meet`;
    
    console.log('üìù Merge prompt:', mergePrompt);
    
    const contents = [
      mergePrompt,
      {
        inlineData: {
          data: image1,
          mimeType: 'image/png'
        }
      },
      {
        inlineData: {
          data: image2,
          mimeType: 'image/png'
        }
      }
    ];
    
    console.log('üöÄ Sending merge request to Gemini...');
    const result = await model.generateContent(contents);
    const response = await result.response;
    
    console.log('üì® Response received from Gemini');
    
    // Look for merged image
    if (response.candidates && response.candidates[0]) {
      const candidate = response.candidates[0];
      
      if (candidate.content && candidate.content.parts) {
        for (const part of candidate.content.parts) {
          if (part.inlineData && part.inlineData.data) {
            console.log('‚úÖ Images merged successfully');
            console.log('üìè Output size:', part.inlineData.data.length);
            return part.inlineData.data;
          }
        }
      }
    }
    
    console.error('‚ùå No merged image in response');
    console.log('üìä Response structure:', {
      hasCandidates: !!response.candidates,
      candidatesLength: response.candidates?.length || 0,
      firstCandidate: !!response.candidates?.[0],
      hasContent: !!response.candidates?.[0]?.content,
      hasParts: !!response.candidates?.[0]?.content?.parts,
      partsLength: response.candidates?.[0]?.content?.parts?.length || 0
    });
    
    return null;
    
  } catch (error) {
    console.error('‚ùå Error merging images:', error);
    if (error instanceof Error) {
      console.error('Error details:', error.message);
      console.error('Stack:', error.stack);
    }
    return null;
  }
}